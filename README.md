# AdvProg-Module8
Name : Siti Shofi Nadhifa <br>
NPM : 2306152172 <br>
Class : AdPro B

## Reflection
### What are the key differences between unary, server streaming, and bi-directional streaming RPC methods? What scenarios would each be most suitable?
There are several key differences of the unary, server streaming, and bi-directional streaming RPC.
- Unary RPC: In Unary RPC, the client sends a single request and receives a single response from the server. It’s comparable to a typical HTTP REST call. This pattern is best suited for straightforward, transactional operations where a one-time exchange of data suffices. For instance, in the `ProcessPayment` service, a user sends payment details, and the server responds with a confirmation or failure status.
- Server Streaming RPC: In server streaming, the client sends one request and the server responds with a stream of messages. This is particularly useful when the server needs to return a large dataset or send real-time updates without repeated requests from the client. A good example is `GetTransactionHistory`, where a user might request their payment history, and the server streams each transaction record individually. This model reduces latency and network overhead, especially when transmitting data over time.
- Bidirectional Streaming RPC: Bidirectional streaming allows both the client and server to send messages to each other independently and asynchronously within the same stream. This model is ideal for highly interactive applications that require real-time two-way communication, such as live chat systems. In the `Chat` service example, the client and server can continuously exchange chat messages without waiting for each other's response, enabling a smoother and more responsive user experience.

### What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
Security is a fundamental aspect of any RPC service.
- Authentication: In a gRPC system, there is always a risk of unauthenticated users attempting to connect to the server. Without a proper authentication mechanism, the service becomes vulnerable to unauthorized access and potential security breaches. Implementing strong authentication ensures that only verified users can connect to the gRPC server. In Rust, this can be achieved using token-based methods such as JWT, which allows each request to be verified before being processed. This approach not only blocks attackers attempting to impersonate legitimate clients but also ensures secure communication across the service.
- Authorization: Even after authentication, it is crucial to control what actions a user is permitted to perform. For instance, in a system with different user roles—such as admin and standard users—regular users should not have access to admin-level functions. Role-based access control (RBAC) is an effective strategy to enforce authorization policies. By defining permissions based on user roles and performing access checks for each operation, we can maintain strict security controls and prevent privilege escalation.
- Data Encryption: Data transmission between the client and server must be protected to prevent interception or unauthorized access. Sending sensitive data in plain text makes it vulnerable to attacks such as eavesdropping or man-in-the-middle (MITM) attacks. This is why encryption using TLS (Transport Layer Security) is essential. In Rust, the Tonic library supports TLS configuration to ensure that all gRPC communication is encrypted. This guarantees that sensitive information, such as user credentials and financial transactions, remains confidential and secure during transmission.

### What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
Handling bidirectional streaming in Rust gRPC introduces challenges that are both architectural and operational. In applications such as chat systems, maintaining the state of multiple concurrent streaming sessions can be complex, especially when trying to ensure consistency, ordering, and error handling. Managing `mpsc` channels and wrapping them with `ReceiverStream` helps abstract some of the complexity, but careful attention is still needed for handling stream termination, client disconnections, and resource cleanup to prevent memory leaks or dangling streams. Proper backpressure mechanisms and user experience considerations also need to be addressed to ensure real-time responsiveness.

### What are the advantages and disadvantages of using the `tokio_stream::wrappers::ReceiverStream` for streaming responses in Rust gRPC services?
Using `tokio_stream::wrappers::ReceiverStream` provides a convenient bridge between asynchronous channels and gRPC streaming interfaces, facilitating server-side response streaming. Its main advantage lies in its simplicity and seamless integration with Tokio's async runtime. However, it may also introduce performance bottlenecks in high-throughput scenarios or complex pipelines due to its internal buffering and channel capacity limitations. The ease of use with performance trade-offs must be balanced, possibly substituting it with custom stream implementations if finer control or efficiency becomes necessary.

### In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?
To enhance maintainability, the code should follow clear modular boundaries. Splitting service implementations (`PaymentService`, `TransactionService`, etc.) into separate modules or files improves clarity. Using traits for service logic decouples interface from implementation, allowing for dependency injection and easier testing. Protobuf definitions can be wrapped with type-safe domain-specific logic, and shared data structures (e.g., user ID validation) should be extracted into utility modules. Grouping logic into reusable middleware-like layers (e.g., for logging or authentication) further promotes extensibility and long-term code health.

### In the `MyPaymentService` implementation, what additional steps might be necessary to handle more complex payment processing logic?
For a `MyPaymentService` implementation to support more complex payment workflows, several enhancements are needed. This could include integrating with third-party payment gateways, validating input with business logic (e.g., balance checks), managing transactional state (pending, completed, failed), and recording logs or audits. Additional fields in the `PaymentRequest` and `PaymentResponse` messages may be introduced to support metadata, error codes, or fraud detection flags. These steps ensure that the service evolves from a simple demo to a production-ready solution.

### What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?
Adopting gRPC fundamentally alters the architecture of distributed systems by encouraging strongly-typed, schema-first development with high performance and tight integration. While gRPC provides excellent performance and support for code generation across multiple languages, interoperability with REST-based systems may require additional work, such as gateway services or protocol translators. Despite this, gRPC’s emphasis on contracts and service definitions fosters clearer API boundaries and better tooling for client/server development.

### What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
Underlying gRPC is HTTP/2, which offers significant advantages over HTTP/1.1, such as multiplexing, header compression, and persistent connections. These features reduce latency and improve throughput for streaming and concurrent communication. Compared to HTTP/1.1 with WebSockets—often used for emulating bidirectional communication—HTTP/2 is more efficient and robust in handling complex communication patterns natively. However, HTTP/2’s complexity and limited browser support (outside gRPC-Web) can sometimes make HTTP/1.1 still preferable for simple, public-facing REST APIs.

### How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?
The difference in communication model between REST APIs and gRPC becomes apparent in scenarios demanding low-latency, real-time feedback. REST’s stateless, request-response model is limited in scenarios requiring continuous interaction or server push. In contrast, gRPC’s support for bidirectional streaming enables real-time features like chat, telemetry, or multiplayer game synchronization with much less overhead. This makes gRPC a superior choice for use cases that demand live, duplex communication.

### What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?
The schema-based nature of gRPC using Protocol Buffers stands in contrast to the flexible, human-readable JSON used in REST APIs. While Protobuf enforces consistency, compactness, and strict typing—critical for performance and tooling, it also introduces a steeper learning curve and debugging difficulty compared to JSON. On the other hand, JSON's schema-less approach offers flexibility and faster iteration, especially in loosely-coupled systems. Choosing between them depends on the project’s need for efficiency, tooling support, and ecosystem compatibility.
